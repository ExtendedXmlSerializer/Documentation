<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Configuration Profiles </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Configuration Profiles ">
    <meta name="generator" content="docfx 2.58.5.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h2 id="configuration-profiles">Configuration Profiles</h2>

<p>The ExtendedXmlSerializer API allows for you to create pre-configured configuration containers, known as configuration profiles.  This is useful for encapsulating re-used configurations so that you can use them across different projects, or if you have different ways you would like to configure your container and would like to easily switch between them during development.</p>
<p>You define your profiles and then create a configuration container through the use of the <code>ConfiguredContainer</code> static class to create a <code>ConfigurationContainer</code> that is configured via the provided configuration profile.</p>
<p>Let's first start with a simple configuration profile:</p>
<pre><code class="lang-csharp">	sealed class Subject
	{
		public int Number { get; set; }

		public string Message { get; set; }
	}

	sealed class SimpleProfile : IConfigurationProfile
	{
		public static SimpleProfile Default { get; } = new SimpleProfile();

		SimpleProfile() {}

		public IConfigurationContainer Get(IConfigurationContainer parameter) 
			=&gt; parameter.Type&lt;Subject&gt;()
		                .Member(x =&gt; x.Message)
		                .Name(&quot;NewMessage&quot;);
	}
</code></pre>
<p>Now let's create a configuration container with the profile.  The configuration profile will apply its encapsulated configurations to the container once it has been created. We do this through the use of a <code>ConfiguredProfile.New</code> call:</p>
<pre><code class="lang-csharp">	IConfigurationContainer container = ConfiguredContainer.New&lt;SimpleProfile&gt;();

	IExtendedXmlSerializer serializer = container.UseAutoFormatting()
	                          .EnableImplicitTyping(typeof(Subject))
	                          .UseOptimizedNamespaces()
	                          .Create();
	var instance = new Subject {Message = &quot;Hello World!&quot;};
	string document = serializer.Serialize(instance);
</code></pre>
<p>And the result of the <code>document</code> variable above is:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Issue282Tests_Profiles-Subject Number=&quot;0&quot; NewMessage=&quot;Hello World!&quot; /&gt;
</code></pre>
<p>You can also combine configuration profiles:</p>
<pre><code class="lang-csharp">	sealed class ComplexProfile : CompositeConfigurationProfile
	{
		public static ComplexProfile Default { get; } = new ComplexProfile();

		ComplexProfile() : base(SimpleProfile.Default, NumberProfile.Default) {}
	}

	sealed class NumberProfile : IConfigurationProfile
	{
		public static NumberProfile Default { get; } = new NumberProfile();

		NumberProfile() {}

		public IConfigurationContainer Get(IConfigurationContainer parameter) 
			=&gt; parameter.Type&lt;Subject&gt;()
                        .Member(x =&gt; x.Number)
                        .Name(&quot;NewNumber&quot;);
	}
</code></pre>
<p>Create:</p>
<pre><code class="lang-csharp">	IConfigurationContainer container = ConfiguredContainer.New&lt;ComplexProfile&gt;();

	IExtendedXmlSerializer serializer = container.UseAutoFormatting()
	                          .EnableImplicitTyping(typeof(Subject))
	                          .UseOptimizedNamespaces()
	                          .Create();
	var instance = new Subject {Message = &quot;Hello World!&quot;, Number = 123};
	string document = serializer.Serialize(instance);
</code></pre>
<p>Result:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Issue282Tests_Profiles-Subject Number=&quot;123&quot; NewMessage=&quot;Hello World!&quot; /&gt;
</code></pre>
<p>The above code is verified and can be reviewed in <a href="https://github.com/ExtendedXmlSerializer/home/blob/6a7b4674e4abd9070309da4fd1b5b75cc9bbfe7b/test/ExtendedXmlSerializer.Tests.ReportedIssues/Issue282Tests_Profiles.cs">a passing test within our test suite here</a>.</p>
<h2 id="references">References</h2>
<p>ExtendedXmlSerializer has support for capturing, storing, and re-establishing references within an object graph.  There are two ways of establishing reference identity: implicit (whereby ExtendedXmlSerializer keeps track of identities for you) and explicit (whereby you explicitly specify an identity field used to define an entity identity).</p>
<p>Let's take a look at these two scenarios and examine their resulting document output.  We will use the following classes in our sample code below:</p>
<pre><code>public class Parent {
    public Child First { get; set; }
    public Child Second { get; set; }
}

public class Child {
    public Guid Id { get; set; }
    public string Message { get; set; }
}
</code></pre>
<h3 id="implicit-references">Implicit References</h3>
<p>Let's create our serializer and serialize a child object after assigning two values of the same instance:</p>
<pre><code>var serializer = new ConfigurationContainer().EnableImplicitTyping(typeof(Parent), typeof(Child))
			                                 .UseOptimizedNamespaces()
			                                 .EnableReferences()
			                                 .Create();

var child = new Child {Id = Guid.Parse(&quot;{64D96027-94CD-4EA4-B102-4EED74BF53B0}&quot;), Message = &quot;Hello World!&quot;};
var instance = new Parent {First = child, Second = child};
var document = serializer.Serialize(instance);
</code></pre>
<p>Note: You can also implicitly apply references specifically to a type:</p>
<pre><code>var serializer = new ConfigurationContainer().EnableImplicitTyping(typeof(Parent), typeof(Child))
			                                 .UseOptimizedNamespaces()
                                             .Type&lt;Child&gt;()
			                                 .EnableReferences()
			                                 .Create();
</code></pre>
<p>In either case, the <code>document</code> variable above contains the following XML (formatted for convenience and readability here):</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Parent xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot;&gt;
	&lt;First exs:identity=&quot;1&quot;&gt;
		&lt;Id&gt;64d96027-94cd-4ea4-b102-4eed74bf53b0&lt;/Id&gt;
		&lt;Message&gt;Hello World!&lt;/Message&gt;
	&lt;/First&gt;
	&lt;Second exs:reference=&quot;1&quot; /&gt;
&lt;/Parent&gt;
</code></pre>
<p>Note the use of <code>exs:identity</code> and <code>exs:reference</code> attributes.  They are used to denote the source reference and subsequent reference pointers throughout the document, respectfully.  In this case, ExtendedXmlSerializer is keeping track of the identity, and is using that by the <code>1</code> identifier.  If an object graph was generated that somehow had a 2nd <code>Child</code> reference, its identifier would be <code>2</code>, and so on.</p>
<p>After a reference has been established in the document, subsequent references to that original reference are denoted by the <code>exs:reference=&quot;&lt;id&gt;&quot;</code> attribute, where <code>&lt;id&gt;</code> is the id of the reference that should returned and assigned within the object graph when it is deserialized.</p>
<h3 id="explicit-references">Explicit References</h3>
<p>Explicit references work much in the same way as implicit references but use different attributes.  It is considered explicit as you explicitly define the identity when configuring the type on the container.  Note that the resulting identity must be unique otherwise references will be lost and/or assigned incorrectly upon deserialization.</p>
<p>Using this code:</p>
<pre><code>var serializer = new ConfigurationContainer().EnableImplicitTyping(typeof(Parent), typeof(Child))
                                             .UseOptimizedNamespaces()
                                             .Type&lt;Child&gt;()
                                             .EnableReferences(x =&gt; x.Id)
                                             .Create()
                                             .ForTesting();
</code></pre>
<p>(Note the use of <code>EnableReferences(x =&gt; x.Id)</code> which explicitly configures the identity field used to establish uniqueness.)</p>
<p>The result is this document (formatted for readability):</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Parent xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot;&gt;
	&lt;First Id=&quot;64d96027-94cd-4ea4-b102-4eed74bf53b0&quot;&gt;
		&lt;Message&gt;Hello World!&lt;/Message&gt;
	&lt;/First&gt;
	&lt;Second exs:entity=&quot;64d96027-94cd-4ea4-b102-4eed74bf53b0&quot; /&gt;
&lt;/Parent&gt;
</code></pre>
<p>Note the use of <code>exs:identity</code> is gone, as well as <code>exs:reference</code>.  When explicit references are used, the original reference is serialized as usual, and the <code>exs:entity</code> is used on subsequent references that point back to its identity field with the provide identity reference.</p>
<h2 id="monitor-serialization-pipeline">Monitor Serialization Pipeline</h2>
<p>One scenario that you might want to engage in is to monitor events during the serialization (and deserialization) process.  You might want to do this for logging or storage purposes.</p>
<p>The <code>ISerializationMonitor</code> [<a href="https://extendedxmlserializer.github.io/documentation/reference/ExtendedXmlSerializer.ExtensionModel.Instances.ISerializationMonitor-1.html">link</a>] has the following callbacks:</p>
<ul>
<li><code>OnSerializing</code></li>
<li><code>OnSerialized</code></li>
<li><code>OnDeserializing</code></li>
<li><code>OnActivating</code></li>
<li><code>OnActivated</code></li>
<li><code>OnDeserialized</code></li>
</ul>
<p>Let's run through a very simple example of this scenario by storing a list of strings whenever they are encountered during a serialization via the <code>OnSerialized</code> callback.</p>
<p>The code written here can be <a href="https://github.com/ExtendedXmlSerializer/home/blob/633274f853684222b4818abbb789bdec41590662/test/ExtendedXmlSerializer.Tests.ReportedIssues/Issue282Tests_Monitor.cs#L14-L52">seen in a passing test defined in our test suite here</a>.</p>
<p>First, define the monitor:</p>
<pre><code class="lang-csharp">	sealed class Monitor : ISerializationMonitor&lt;string&gt;
	{
		readonly List&lt;string&gt; _store;

		public Monitor(List&lt;string&gt; store) =&gt; _store = store;

		public void OnSerializing(IFormatWriter writer, string instance) {}

		public void OnSerialized(IFormatWriter writer, string instance)
		{
			_store.Add(instance);
		}

		public void OnDeserializing(IFormatReader reader, Type instanceType) {}

		public void OnActivating(IFormatReader reader, Type instanceType) {}

		public void OnActivated(string instance) {}

		public void OnDeserialized(IFormatReader reader, string instance) {}
	}
</code></pre>
<p>And our subject:</p>
<pre><code class="lang-csharp">	sealed class Subject
	{
		public string Message { get; set; }
	}
</code></pre>
<p>And finally our serializer instance:</p>
<pre><code class="lang-csharp">	var instances = new List&lt;string&gt;();
	IExtendedXmlSerializer serializer = new ConfigurationContainer().Type&lt;string&gt;()
	                                                                .WithMonitor(new Monitor(instances))
	                                                                .Create();
</code></pre>
<p>Now let's serialize one of our subject's with a message:</p>
<pre><code>	const string message = &quot;Hello World!&quot;;
	string document = serializer.Serialize(new Subject {Message = message});
</code></pre>
<p>When we poll the <code>instances</code> variable above now, we see that it contains the <code>Hello World!</code> message.</p>
<p>For a full working test demonstrating this scenario, <a href="https://github.com/ExtendedXmlSerializer/home/blob/633274f853684222b4818abbb789bdec41590662/test/ExtendedXmlSerializer.Tests.ReportedIssues/Issue282Tests_Monitor.cs#L14-L52">see the test described here</a>.</p>
<h2 id="create-an-extension">Create an Extension</h2>
<p>Creating an extension is at the heart of ExtendedXmlSerializer's extension model.</p>
<p>In this very simple example, we are going to extend the configuration container that creates our root serializer to create a content serializer so that it always add the number <code>42</code> whenever it encounters number during both serialization and deserialization.</p>
<p>Here's our subject:</p>
<pre><code class="lang-csharp">	sealed class Subject
	{
		public int Number { get; set; }
	}
</code></pre>
<p>If we create an instance of this subject with its <code>Number</code> set to <code>10</code>, it will serialize that value with <code>52</code> and then deserialize with a</p>
<p>Now, why on earth would we ever want to do this?! For demonstration purposes, of course! 😁</p>
<p>All of the code provided in this article can be <a href="https://github.com/ExtendedXmlSerializer/home/blob/9824a628c911f6d46e1cb73d08be8e3200240cbe/test/ExtendedXmlSerializer.Tests.ReportedIssues/Issue282Tests_Extension.cs#L17-L80">found in the form of a passing test as defined here</a>.</p>
<p>Let's begin by defining our extension:</p>
<pre><code class="lang-csharp">    sealed class Extension : ISerializerExtension
	{
		public static Extension Default { get; } = new Extension();

		Extension() {}

		public IServiceRepository Get(IServiceRepository parameter) =&gt; parameter.DecorateContentsWith&lt;Contents&gt;()
		                                                                        .Then();

		void ICommand&lt;IServices&gt;.Execute(IServices parameter) {}

		sealed class Contents : IContents
		{
			readonly IContents        _previous;
			readonly ISerializer&lt;int&gt; _number;

			public Contents(IContents previous)
				: this(previous, new AnswerToEverythingSerializer(previous.Get(typeof(int)).For&lt;int&gt;())) {}

			public Contents(IContents previous, ISerializer&lt;int&gt; number)
			{
				_previous = previous;
				_number   = number;
			}

			public ISerializer Get(TypeInfo parameter)
				=&gt; parameter == typeof(int) ? _number.Adapt() : _previous.Get(parameter);
		}

		sealed class AnswerToEverythingSerializer : ISerializer&lt;int&gt;
		{
			readonly ISerializer&lt;int&gt; _previous;

			public AnswerToEverythingSerializer(ISerializer&lt;int&gt; previous) =&gt; _previous = previous;

			public int Get(IFormatReader parameter) =&gt; _previous.Get(parameter) + 42;

			public void Write(IFormatWriter writer, int instance)
			{
				_previous.Write(writer, instance + 42);
			}
		}
	}
</code></pre>
<p>Here this extension is used to register the <code>AnswerToEverythingSerializer</code> whenever a content serializer is requested for the type of <code>int</code>.  The <code>AnswerToEverythingSerializer</code> adds <code>42</code> to a number when it serializes and then <code>42</code> again to a value when it deserializes it.</p>
<p>Now let's create a container that is extended with this extension:</p>
<pre><code class="lang-csharp">	IExtendedXmlSerializer serializer = new ConfigurationContainer().EnableImplicitTyping(typeof(Subject))
	                                                                .Extend(Extension.Default)
	                                                                .Create();
	string document = serializer.Serialize(new Subject(){Number = 10});
</code></pre>
<p>When we inspect the <code>document</code> variable above, we get the following XML:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;
&lt;Subject&gt;&lt;Number&gt;52&lt;/Number&gt;&lt;/Subject&gt;
</code></pre>
<p>Now let's deserialize it:</p>
<pre><code class="lang-csharp">var number = serializer.Deserialize&lt;Subject&gt;(document).Number;
</code></pre>
<p>Inspecting the <code>number</code> variable reveals <code>94</code> as it added <code>42</code> to the serialized value of <code>52</code>.</p>
<p>This is a very contrived example but hopefully it communicates the power of the extension model that is available in ExtendedXmlSerializer.  For a working example of the code above, <a href="https://github.com/ExtendedXmlSerializer/home/blob/9824a628c911f6d46e1cb73d08be8e3200240cbe/test/ExtendedXmlSerializer.Tests.ReportedIssues/Issue282Tests_Extension.cs#L17-L80">check out the passing test</a> that is in our test suite that demonstrates the above scenario.</p>
<h2 id="register-custom-serializer">Register Custom Serializer</h2>
<p>You have full control over the serialization of a particular type.  Consider the following class structure:</p>
<pre><code class="lang-csharp">	public class Subject
	{
		public Subject(string text, int number)
		{
			Text   = text;
			Number = number;
		}

		public string Text { get; }
		public int Number { get; }
	}
</code></pre>
<p>Now, while it is possible to use <code>EnableParameterizedContent</code> [<a href="https://github.com/ExtendedXmlSerializer/home/wiki/Features#immutable-classes-and-content">feature</a>, <a href="https://extendedxmlserializer.github.io/documentation/reference/ExtendedXmlSerializer.ExtensionMethodsForContent.html#ExtendedXmlSerializer_ExtensionMethodsForContent_EnableParameterizedContent_ExtendedXmlSerializer_Configuration_IConfigurationContainer_">API</a>] to serialize and deserialize the above contract, what we want to demonstrate here is the ability to have full control over how the above is stored and retrieved.</p>
<p>The following code can be <a href="https://github.com/ExtendedXmlSerializer/home/blob/master/test/ExtendedXmlSerializer.Tests.ReportedIssues/Issue282Tests.cs#L12-L56">found in a passing test stored here</a>.</p>
<p>First, let's create a serializer:</p>
<pre><code class="lang-csharp">	sealed class SubjectSerializer : ISerializer&lt;Subject&gt;
	{
		public static SubjectSerializer Default { get; } = new SubjectSerializer();

		SubjectSerializer() {}

		public Subject Get(IFormatReader parameter)
		{
			var parts  = parameter.Content().Split('|');
			var result = new Subject(parts[0], int.Parse(parts[1]));
			return result;
		}

		public void Write(IFormatWriter writer, Subject instance)
		{
			writer.Content($&quot;{instance.Text}|{instance.Number}&quot;);
		}
	}
</code></pre>
<p>The above is very rudimentary and extremely error-prone (particularly the <code>int.Parse</code> call), but again what we are demonstrating here is full control over the serialization and deserialization process for this particular type.  If you feel so inclined (and maybe a little crazy 😅), you could even modify the serializer to send and retrieve data from a database.</p>
<p>That is the point (and power!) of this scenario, as well as demonstrating how to register a serializer for a particular type.</p>
<p>Now that we have the serializer created, let's register it and create a root container:</p>
<pre><code class="lang-csharp">	IExtendedXmlSerializer serializer = new ConfigurationContainer().Type&lt;Subject&gt;()
	                                                                .Register()
	                                                                .Serializer()
	                                                                .Using(SubjectSerializer.Default)
	                                                                .Create();
    Subject instance = new Subject(&quot;Hello World!&quot;, 123);
	string document = serializer.Serialize(instance);
</code></pre>
<p>The above will create the following XML:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Subject xmlns=&quot;clr-namespace:Namespace;assembly=Assembly&quot;&gt;Hello World!|123&lt;/Subject&gt;
</code></pre>
<p>The above code can be <a href="https://github.com/ExtendedXmlSerializer/home/blob/master/test/ExtendedXmlSerializer.Tests.ReportedIssues/Issue282Tests.cs#L12-L56">viewed as a passing test here</a>.</p>
<h2 id="register-a-converter">Register a Converter</h2>
<p>While registering a serializer is meant for more complex serialization scenarios, you can use an <code>IConverter&lt;T&gt;</code> for simple <code>string</code>-based conversion implementations.  Let's walk through a simple example here.</p>
<p>First, start by defining your converter for a type:</p>
<pre><code class="lang-csharp">	sealed class Subject
	{
		public string Message { get; set; }
	}

	sealed class SubjectConverter : ConverterBase&lt;Subject&gt;
	{
		public static SubjectConverter Default { get; } = new SubjectConverter();

		SubjectConverter() {}

		public override Subject Parse(string data) =&gt; new Subject {Message = data};

		public override string Format(Subject instance) =&gt; instance.Message;
	}
</code></pre>
<p>Register it and serialize:</p>
<pre><code class="lang-csharp">	IExtendedXmlSerializer serializer = new ConfigurationContainer().EnableImplicitTyping(typeof(Subject))
	                                                                .Type&lt;Subject&gt;()
	                                                                .Register()
	                                                                .Converter()
	                                                                .Using(SubjectConverter.Default)
	                                                                .Create();

	var instance = new Subject {Message = &quot;Hello World!&quot;};
	string document = serializer.Serialize(instance);
</code></pre>
<p>Result:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;&lt;Subject&gt;Hello World!&lt;/Subject&gt;
</code></pre>
<p>The above code can be reviewed in <a href="https://github.com/ExtendedXmlSerializer/home/blob/8ae06e2aff399a32625f0f7c29a68a2631646484/test/ExtendedXmlSerializer.Tests.ReportedIssues/Issue282Tests_Converters.cs">a passing test within our test suite here</a>.</p>
<h2 id="serialization-of-dictionary">Serialization of Dictionary</h2>
<p>You can serialize generic dictionary, that can store any type.</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public Dictionary&lt;int, string&gt; Dictionary { get; set; }
    }
</code></pre>
<pre><code class="lang-csharp">    TestClass obj = new TestClass
    {
        Dictionary = new Dictionary&lt;int, string&gt;
        {
            {1, &quot;First&quot;},
            {2, &quot;Second&quot;},
            {3, &quot;Other&quot;},
        }
    };
</code></pre>
<p>Output XML will look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Dictianary;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Dictionary&gt;
        &lt;Item xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
          &lt;Key&gt;1&lt;/Key&gt;
          &lt;Value&gt;First&lt;/Value&gt;
        &lt;/Item&gt;
        &lt;Item xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
          &lt;Key&gt;2&lt;/Key&gt;
          &lt;Value&gt;Second&lt;/Value&gt;
        &lt;/Item&gt;
        &lt;Item xmlns=&quot;https://extendedxmlserializer.github.io/system&quot;&gt;
          &lt;Key&gt;3&lt;/Key&gt;
          &lt;Value&gt;Other&lt;/Value&gt;
        &lt;/Item&gt;
      &lt;/Dictionary&gt;
    &lt;/TestClass&gt;
</code></pre>
<p>If you use <code>UseOptimizedNamespaces</code> function xml will look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns:sys=&quot;https://extendedxmlserializer.github.io/system&quot; xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.Dictianary;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Dictionary&gt;
        &lt;sys:Item&gt;
          &lt;Key&gt;1&lt;/Key&gt;
          &lt;Value&gt;First&lt;/Value&gt;
        &lt;/sys:Item&gt;
        &lt;sys:Item&gt;
          &lt;Key&gt;2&lt;/Key&gt;
          &lt;Value&gt;Second&lt;/Value&gt;
        &lt;/sys:Item&gt;
        &lt;sys:Item&gt;
          &lt;Key&gt;3&lt;/Key&gt;
          &lt;Value&gt;Other&lt;/Value&gt;
        &lt;/sys:Item&gt;
      &lt;/Dictionary&gt;
    &lt;/TestClass&gt;
</code></pre>
<h2 id="migrate-xml-based-on-older-class-model">Migrate XML Based on Older Class Model</h2>
<p>In standard XMLSerializer you can't deserialize XML in case you change
model. In ExtendedXMLSerializer you can create migrator for each class
separately. E.g.: If you have big class, that uses small class and this
small class will be changed you can create migrator only for this small
class. You don't have to modify whole big XML. Now I will show you a
simple example.</p>
<p>If you had a class:</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public int Id { get; set; }
        public string Type { get; set; }
    }
</code></pre>
<p>and generated XML look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns=&quot;clr-namespace:ExtendedXmlSerialization.Samples.MigrationMap;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Id&gt;1&lt;/Id&gt;
      &lt;Type&gt;Type&lt;/Type&gt;
    &lt;/TestClass&gt;
</code></pre>
<p>Then you renamed property:</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }
</code></pre>
<p>and generated XML look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:version=&quot;1&quot; xmlns=&quot;clr-namespace:ExtendedXmlSerialization.Samples.MigrationMap;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Id&gt;1&lt;/Id&gt;
      &lt;Name&gt;Type&lt;/Name&gt;
    &lt;/TestClass&gt;
</code></pre>
<p>Then, you added new property and you wanted to calculate a new value during deserialization.</p>
<pre><code class="lang-csharp">    public class TestClass
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Value { get; set; }
    }
</code></pre>
<p>and new XML should look like:</p>
<pre><code class="lang-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;TestClass xmlns:exs=&quot;https://extendedxmlserializer.github.io/v2&quot; exs:version=&quot;2&quot; xmlns=&quot;clr-namespace:ExtendedXmlSerializer.Samples.MigrationMap;assembly=ExtendedXmlSerializer.Samples&quot;&gt;
      &lt;Id&gt;1&lt;/Id&gt;
      &lt;Name&gt;Type&lt;/Name&gt;
      &lt;Value&gt;Calculated&lt;/Value&gt;
    &lt;/TestClass&gt;
</code></pre>
<p>You can migrate (read) old version of XML using migrations:</p>
<pre><code class="lang-csharp">    public class TestClassMigrations : IEnumerable&lt;Action&lt;XElement&gt;&gt;
    {
        public static void MigrationV0(XElement node)
        {
            XElement typeElement = node.Member(&quot;Type&quot;);
            // Add new node
            node.Add(new XElement(&quot;Name&quot;, typeElement.Value));
            // Remove old node
            typeElement.Remove();
        }
    
        public static void MigrationV1(XElement node)
        {
            // Add new node
            node.Add(new XElement(&quot;Value&quot;, &quot;Calculated&quot;));
        }
    
        IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
    
        public IEnumerator&lt;Action&lt;XElement&gt;&gt; GetEnumerator()
        {
            yield return MigrationV0;
            yield return MigrationV1;
        }
    }
</code></pre>
<p>Then, you must register your <code>TestClassMigrations</code> class in configuration</p>
<pre><code class="lang-csharp">    IExtendedXmlSerializer serializer = new ConfigurationContainer().ConfigureType&lt;TestClass&gt;()
                                                                    .AddMigration(new TestClassMigrations())
                                                                    .Create();
</code></pre>
<h2 id="unknown-content">Unknown Content</h2>
<p>Consider the following class:</p>
<pre><code>class Subject {
    public string Message { get; set; }
}
</code></pre>
<p>And the following Xml:</p>
<pre><code>&lt;Subject&gt;
	&lt;Unknown&gt;Unexpected content will abort.&lt;/Unknown&gt;
    &lt;Message&gt;Hello World!&lt;/Message&gt;
&lt;/Subject&gt;
</code></pre>
<p>By default as of 3.x functionality, ExtendedXmlSerializer aborts its reading of the XML document when it reaches any content that it cannot deserialize into the target object.  In this case, this is the <code>Unknown</code> element in the provided XML document.</p>
<p>The result of this aborted operation is an incomplete object that is not fully deserialized, with values not applied to object properties that were not reached before the encountered invalid content in the XML document.</p>
<p>It is fair to say that this is not exactly ideal functionality and it should rather throw to promote better visibility of an invalid document.  In a future breaking change version this will be done after considering community feedback.</p>
<p>However, in the meantime, ExtendedXmlSerializer does provide some control over this scenario for v3.x, via the <code>WithUnknownContent</code> method call:</p>
<pre><code>var serializer = new ConfigurationContainer().EnableImplicitTyping(typeof(Subject))
                                             .WithUnknownContent()
                                             .Continue()
                                             .Create();
...
</code></pre>
<p>The <code>WithUnknownContent</code> has 3 different options:</p>
<ol>
<li><em>Continue</em>.  This will ignore unknown content and continue reading the document, attempting to process the next element.</li>
<li><em>Throw</em>.  This will throw an exception whenever unknown content is encountered.</li>
<li><em>Call</em>.  Provide a delegate to invoke whenever unknown content is encountered (for logging, etc.)</li>
</ol>
<p>More discussion around this can be found at the following issue:
<a href="https://github.com/ExtendedXmlSerializer/home/issues/393">https://github.com/ExtendedXmlSerializer/home/issues/393</a></p>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/ExtendedXmlSerializer/home.wiki/blob/master/Example-Scenarios.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
